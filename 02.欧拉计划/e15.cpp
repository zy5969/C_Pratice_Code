/*************************************************************************
从一个网格的左上角出发，若只允许向右或向下移动，
则恰好有条抵达右下角的路径。
对于网格20*20，这样的路径有多少条
 ************************************************************************/

//40!/(20!*20!),40中选择20排列组合
#include<iostream>
using namespace std;

int main() {
    int n = 20, m = 40;
    long long sum = 1, sum1 = 1;
    for(int i = 1; i <= n; i++){
        sum = (i + n) * sum / i;//40位中选出20位
    }
    while(n > 1){
        if(m > 20) sum1 *= (m--);//(40*...*21)
        if(n && sum1 % n == 0) sum1 /= (n--);//sum/20!
    }
    cout << "公式: " << sum << endl;
    cout << "阶层: " << sum1 << endl;
    return 0;
}

